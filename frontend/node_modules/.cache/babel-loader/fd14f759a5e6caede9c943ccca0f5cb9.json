{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"/Users/tmouchelet-admin/Documents/upload-node-master/frontend/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _toArray = require(\"/Users/tmouchelet-admin/Documents/upload-node-master/frontend/node_modules/@babel/runtime/helpers/toArray\");\n\nvar _regeneratorRuntime = require(\"/Users/tmouchelet-admin/Documents/upload-node-master/frontend/node_modules/@babel/runtime/regenerator\");\n\nvar _slicedToArray = require(\"/Users/tmouchelet-admin/Documents/upload-node-master/frontend/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _asyncToGenerator = require(\"/Users/tmouchelet-admin/Documents/upload-node-master/frontend/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _objectSpread = require(\"/Users/tmouchelet-admin/Documents/upload-node-master/frontend/node_modules/@babel/runtime/helpers/objectSpread\");\n\nvar path = require('path');\n\nvar childProcess = require('child_process');\n\nvar crossSpawn = require('cross-spawn');\n\nvar stripFinalNewline = require('strip-final-newline');\n\nvar npmRunPath = require('npm-run-path');\n\nvar onetime = require('onetime');\n\nvar makeError = require('./lib/error');\n\nvar normalizeStdio = require('./lib/stdio');\n\nvar _require = require('./lib/kill'),\n    spawnedKill = _require.spawnedKill,\n    spawnedCancel = _require.spawnedCancel,\n    setupTimeout = _require.setupTimeout,\n    setExitHandler = _require.setExitHandler;\n\nvar _require2 = require('./lib/stream.js'),\n    handleInput = _require2.handleInput,\n    getSpawnedResult = _require2.getSpawnedResult,\n    makeAllStream = _require2.makeAllStream,\n    validateInputSync = _require2.validateInputSync;\n\nvar _require3 = require('./lib/promise.js'),\n    mergePromise = _require3.mergePromise,\n    getSpawnedPromise = _require3.getSpawnedPromise;\n\nvar _require4 = require('./lib/command.js'),\n    joinCommand = _require4.joinCommand,\n    parseCommand = _require4.parseCommand;\n\nvar DEFAULT_MAX_BUFFER = 1000 * 1000 * 100;\n\nvar getEnv = function getEnv(_ref) {\n  var envOption = _ref.env,\n      extendEnv = _ref.extendEnv,\n      preferLocal = _ref.preferLocal,\n      localDir = _ref.localDir,\n      execPath = _ref.execPath;\n  var env = extendEnv ? _objectSpread({}, process.env, envOption) : envOption;\n\n  if (preferLocal) {\n    return npmRunPath.env({\n      env: env,\n      cwd: localDir,\n      execPath: execPath\n    });\n  }\n\n  return env;\n};\n\nvar handleArgs = function handleArgs(file, args) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  var parsed = crossSpawn._parse(file, args, options);\n\n  file = parsed.command;\n  args = parsed.args;\n  options = parsed.options;\n  options = _objectSpread({\n    maxBuffer: DEFAULT_MAX_BUFFER,\n    buffer: true,\n    stripFinalNewline: true,\n    extendEnv: true,\n    preferLocal: false,\n    localDir: options.cwd || process.cwd(),\n    execPath: process.execPath,\n    encoding: 'utf8',\n    reject: true,\n    cleanup: true,\n    all: false,\n    windowsHide: true\n  }, options);\n  options.env = getEnv(options);\n  options.stdio = normalizeStdio(options);\n\n  if (process.platform === 'win32' && path.basename(file, '.exe') === 'cmd') {\n    // #116\n    args.unshift('/q');\n  }\n\n  return {\n    file: file,\n    args: args,\n    options: options,\n    parsed: parsed\n  };\n};\n\nvar handleOutput = function handleOutput(options, value, error) {\n  if (typeof value !== 'string' && !Buffer.isBuffer(value)) {\n    // When `execa.sync()` errors, we normalize it to '' to mimic `execa()`\n    return error === undefined ? undefined : '';\n  }\n\n  if (options.stripFinalNewline) {\n    return stripFinalNewline(value);\n  }\n\n  return value;\n};\n\nvar execa = function execa(file, args, options) {\n  var parsed = handleArgs(file, args, options);\n  var command = joinCommand(file, args);\n  var spawned;\n\n  try {\n    spawned = childProcess.spawn(parsed.file, parsed.args, parsed.options);\n  } catch (error) {\n    // Ensure the returned error is always both a promise and a child process\n    var dummySpawned = new childProcess.ChildProcess();\n    var errorPromise = Promise.reject(makeError({\n      error: error,\n      stdout: '',\n      stderr: '',\n      all: '',\n      command: command,\n      parsed: parsed,\n      timedOut: false,\n      isCanceled: false,\n      killed: false\n    }));\n    return mergePromise(dummySpawned, errorPromise);\n  }\n\n  var spawnedPromise = getSpawnedPromise(spawned);\n  var timedPromise = setupTimeout(spawned, parsed.options, spawnedPromise);\n  var processDone = setExitHandler(spawned, parsed.options, timedPromise);\n  var context = {\n    isCanceled: false\n  };\n  spawned.kill = spawnedKill.bind(null, spawned.kill.bind(spawned));\n  spawned.cancel = spawnedCancel.bind(null, spawned, context);\n\n  var handlePromise =\n  /*#__PURE__*/\n  function () {\n    var _ref2 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee() {\n      var _ref3, _ref4, _ref4$, error, exitCode, signal, timedOut, stdoutResult, stderrResult, allResult, stdout, stderr, all, returnedError;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return getSpawnedResult(spawned, parsed.options, processDone);\n\n            case 2:\n              _ref3 = _context.sent;\n              _ref4 = _slicedToArray(_ref3, 4);\n              _ref4$ = _ref4[0];\n              error = _ref4$.error;\n              exitCode = _ref4$.exitCode;\n              signal = _ref4$.signal;\n              timedOut = _ref4$.timedOut;\n              stdoutResult = _ref4[1];\n              stderrResult = _ref4[2];\n              allResult = _ref4[3];\n              stdout = handleOutput(parsed.options, stdoutResult);\n              stderr = handleOutput(parsed.options, stderrResult);\n              all = handleOutput(parsed.options, allResult);\n\n              if (!(error || exitCode !== 0 || signal !== null)) {\n                _context.next = 20;\n                break;\n              }\n\n              returnedError = makeError({\n                error: error,\n                exitCode: exitCode,\n                signal: signal,\n                stdout: stdout,\n                stderr: stderr,\n                all: all,\n                command: command,\n                parsed: parsed,\n                timedOut: timedOut,\n                isCanceled: context.isCanceled,\n                killed: spawned.killed\n              });\n\n              if (parsed.options.reject) {\n                _context.next = 19;\n                break;\n              }\n\n              return _context.abrupt(\"return\", returnedError);\n\n            case 19:\n              throw returnedError;\n\n            case 20:\n              return _context.abrupt(\"return\", {\n                command: command,\n                exitCode: 0,\n                stdout: stdout,\n                stderr: stderr,\n                all: all,\n                failed: false,\n                timedOut: false,\n                isCanceled: false,\n                killed: false\n              });\n\n            case 21:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, this);\n    }));\n\n    return function handlePromise() {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n\n  var handlePromiseOnce = onetime(handlePromise);\n\n  crossSpawn._enoent.hookChildProcess(spawned, parsed.parsed);\n\n  handleInput(spawned, parsed.options.input);\n  spawned.all = makeAllStream(spawned, parsed.options);\n  return mergePromise(spawned, handlePromiseOnce);\n};\n\nmodule.exports = execa;\n\nmodule.exports.sync = function (file, args, options) {\n  var parsed = handleArgs(file, args, options);\n  var command = joinCommand(file, args);\n  validateInputSync(parsed.options);\n  var result;\n\n  try {\n    result = childProcess.spawnSync(parsed.file, parsed.args, parsed.options);\n  } catch (error) {\n    throw makeError({\n      error: error,\n      stdout: '',\n      stderr: '',\n      all: '',\n      command: command,\n      parsed: parsed,\n      timedOut: false,\n      isCanceled: false,\n      killed: false\n    });\n  }\n\n  var stdout = handleOutput(parsed.options, result.stdout, result.error);\n  var stderr = handleOutput(parsed.options, result.stderr, result.error);\n\n  if (result.error || result.status !== 0 || result.signal !== null) {\n    var error = makeError({\n      stdout: stdout,\n      stderr: stderr,\n      error: result.error,\n      signal: result.signal,\n      exitCode: result.status,\n      command: command,\n      parsed: parsed,\n      timedOut: result.error && result.error.code === 'ETIMEDOUT',\n      isCanceled: false,\n      killed: result.signal !== null\n    });\n\n    if (!parsed.options.reject) {\n      return error;\n    }\n\n    throw error;\n  }\n\n  return {\n    command: command,\n    exitCode: 0,\n    stdout: stdout,\n    stderr: stderr,\n    failed: false,\n    timedOut: false,\n    isCanceled: false,\n    killed: false\n  };\n};\n\nmodule.exports.command = function (command, options) {\n  var _parseCommand = parseCommand(command),\n      _parseCommand2 = _toArray(_parseCommand),\n      file = _parseCommand2[0],\n      args = _parseCommand2.slice(1);\n\n  return execa(file, args, options);\n};\n\nmodule.exports.commandSync = function (command, options) {\n  var _parseCommand3 = parseCommand(command),\n      _parseCommand4 = _toArray(_parseCommand3),\n      file = _parseCommand4[0],\n      args = _parseCommand4.slice(1);\n\n  return execa.sync(file, args, options);\n};\n\nmodule.exports.node = function (scriptPath, args) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (args && !Array.isArray(args) && typeof args === 'object') {\n    options = args;\n    args = [];\n  }\n\n  var stdio = normalizeStdio.node(options);\n  var _options = options,\n      _options$nodePath = _options.nodePath,\n      nodePath = _options$nodePath === void 0 ? process.execPath : _options$nodePath,\n      _options$nodeOptions = _options.nodeOptions,\n      nodeOptions = _options$nodeOptions === void 0 ? process.execArgv : _options$nodeOptions;\n  return execa(nodePath, [].concat(_toConsumableArray(nodeOptions), [scriptPath], _toConsumableArray(Array.isArray(args) ? args : [])), _objectSpread({}, options, {\n    stdin: undefined,\n    stdout: undefined,\n    stderr: undefined,\n    stdio: stdio,\n    shell: false\n  }));\n};","map":null,"metadata":{},"sourceType":"script"}
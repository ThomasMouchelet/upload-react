{"ast":null,"code":"\"use strict\";\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nvar is = require('is_js');\n/**\n * Parse x-forwarded-for headers.\n *\n * @param {string} value - The value to be parsed.\n * @return {string|null} First known IP address, if any.\n */\n\n\nfunction getClientIpFromXForwardedFor(value) {\n  if (!is.existy(value)) {\n    return null;\n  }\n\n  if (is.not.string(value)) {\n    throw new TypeError(\"Expected a string, got \\\"\".concat(_typeof(value), \"\\\"\"));\n  } // x-forwarded-for may return multiple IP addresses in the format:\n  // \"client IP, proxy 1 IP, proxy 2 IP\"\n  // Therefore, the right-most IP address is the IP address of the most recent proxy\n  // and the left-most IP address is the IP address of the originating client.\n  // source: http://docs.aws.amazon.com/elasticloadbalancing/latest/classic/x-forwarded-headers.html\n  // Azure Web App's also adds a port for some reason, so we'll only use the first part (the IP)\n\n\n  var forwardedIps = value.split(',').map(function (e) {\n    var ip = e.trim();\n\n    if (ip.includes(':')) {\n      var splitted = ip.split(':'); // make sure we only use this if it's ipv4 (ip:port)\n\n      if (splitted.length === 2) {\n        return splitted[0];\n      }\n    }\n\n    return ip;\n  }); // Sometimes IP addresses in this header can be 'unknown' (http://stackoverflow.com/a/11285650).\n  // Therefore taking the left-most IP address that is not unknown\n  // A Squid configuration directive can also set the value to \"unknown\" (http://www.squid-cache.org/Doc/config/forwarded_for/)\n\n  return forwardedIps.find(is.ip);\n}\n/**\n * Determine client IP address.\n *\n * @param req\n * @returns {string} ip - The IP address if known, defaulting to empty string if unknown.\n */\n\n\nfunction getClientIp(req) {\n  // Server is probably behind a proxy.\n  if (req.headers) {\n    // Standard headers used by Amazon EC2, Heroku, and others.\n    if (is.ip(req.headers['x-client-ip'])) {\n      return req.headers['x-client-ip'];\n    } // Load-balancers (AWS ELB) or proxies.\n\n\n    var xForwardedFor = getClientIpFromXForwardedFor(req.headers['x-forwarded-for']);\n\n    if (is.ip(xForwardedFor)) {\n      return xForwardedFor;\n    } // Cloudflare.\n    // @see https://support.cloudflare.com/hc/en-us/articles/200170986-How-does-Cloudflare-handle-HTTP-Request-headers-\n    // CF-Connecting-IP - applied to every request to the origin.\n\n\n    if (is.ip(req.headers['cf-connecting-ip'])) {\n      return req.headers['cf-connecting-ip'];\n    } // Fastly and Firebase hosting header (When forwared to cloud function)\n\n\n    if (is.ip(req.headers['fastly-client-ip'])) {\n      return req.headers['fastly-client-ip'];\n    } // Akamai and Cloudflare: True-Client-IP.\n\n\n    if (is.ip(req.headers['true-client-ip'])) {\n      return req.headers['true-client-ip'];\n    } // Default nginx proxy/fcgi; alternative to x-forwarded-for, used by some proxies.\n\n\n    if (is.ip(req.headers['x-real-ip'])) {\n      return req.headers['x-real-ip'];\n    } // (Rackspace LB and Riverbed's Stingray)\n    // http://www.rackspace.com/knowledge_center/article/controlling-access-to-linux-cloud-sites-based-on-the-client-ip-address\n    // https://splash.riverbed.com/docs/DOC-1926\n\n\n    if (is.ip(req.headers['x-cluster-client-ip'])) {\n      return req.headers['x-cluster-client-ip'];\n    }\n\n    if (is.ip(req.headers['x-forwarded'])) {\n      return req.headers['x-forwarded'];\n    }\n\n    if (is.ip(req.headers['forwarded-for'])) {\n      return req.headers['forwarded-for'];\n    }\n\n    if (is.ip(req.headers.forwarded)) {\n      return req.headers.forwarded;\n    }\n  } // Remote address checks.\n\n\n  if (is.existy(req.connection)) {\n    if (is.ip(req.connection.remoteAddress)) {\n      return req.connection.remoteAddress;\n    }\n\n    if (is.existy(req.connection.socket) && is.ip(req.connection.socket.remoteAddress)) {\n      return req.connection.socket.remoteAddress;\n    }\n  }\n\n  if (is.existy(req.socket) && is.ip(req.socket.remoteAddress)) {\n    return req.socket.remoteAddress;\n  }\n\n  if (is.existy(req.info) && is.ip(req.info.remoteAddress)) {\n    return req.info.remoteAddress;\n  } // AWS Api Gateway + Lambda\n\n\n  if (is.existy(req.requestContext) && is.existy(req.requestContext.identity) && is.ip(req.requestContext.identity.sourceIp)) {\n    return req.requestContext.identity.sourceIp;\n  }\n\n  return null;\n}\n/**\n * Expose request IP as a middleware.\n *\n * @param {object} [options] - Configuration.\n * @param {string} [options.attributeName] - Name of attribute to augment request object with.\n * @return {*}\n */\n\n\nfunction mw(options) {\n  // Defaults.\n  var configuration = is.not.existy(options) ? {} : options; // Validation.\n\n  if (is.not.object(configuration)) {\n    throw new TypeError('Options must be an object!');\n  }\n\n  var attributeName = configuration.attributeName || 'clientIp';\n  return function (req, res, next) {\n    var ip = getClientIp(req);\n    Object.defineProperty(req, attributeName, {\n      get: function get() {\n        return ip;\n      },\n      configurable: true\n    });\n    next();\n  };\n}\n\nmodule.exports = {\n  getClientIpFromXForwardedFor: getClientIpFromXForwardedFor,\n  getClientIp: getClientIp,\n  mw: mw\n};","map":null,"metadata":{},"sourceType":"script"}
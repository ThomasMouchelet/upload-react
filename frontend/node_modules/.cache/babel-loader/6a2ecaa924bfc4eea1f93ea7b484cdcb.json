{"ast":null,"code":"'use strict';\n\nvar os = require('os');\n\nvar onExit = require('signal-exit');\n\nvar pFinally = require('p-finally');\n\nvar DEFAULT_FORCE_KILL_TIMEOUT = 1000 * 5; // Monkey-patches `childProcess.kill()` to add `forceKillAfterTimeout` behavior\n\nvar spawnedKill = function spawnedKill(kill) {\n  var signal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'SIGTERM';\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var killResult = kill(signal);\n  setKillTimeout(kill, signal, options, killResult);\n  return killResult;\n};\n\nvar setKillTimeout = function setKillTimeout(kill, signal, options, killResult) {\n  if (!shouldForceKill(signal, options, killResult)) {\n    return;\n  }\n\n  var timeout = getForceKillAfterTimeout(options);\n  setTimeout(function () {\n    kill('SIGKILL');\n  }, timeout).unref();\n};\n\nvar shouldForceKill = function shouldForceKill(signal, _ref, killResult) {\n  var forceKillAfterTimeout = _ref.forceKillAfterTimeout;\n  return isSigterm(signal) && forceKillAfterTimeout !== false && killResult;\n};\n\nvar isSigterm = function isSigterm(signal) {\n  return signal === os.constants.signals.SIGTERM || typeof signal === 'string' && signal.toUpperCase() === 'SIGTERM';\n};\n\nvar getForceKillAfterTimeout = function getForceKillAfterTimeout(_ref2) {\n  var _ref2$forceKillAfterT = _ref2.forceKillAfterTimeout,\n      forceKillAfterTimeout = _ref2$forceKillAfterT === void 0 ? true : _ref2$forceKillAfterT;\n\n  if (forceKillAfterTimeout === true) {\n    return DEFAULT_FORCE_KILL_TIMEOUT;\n  }\n\n  if (!Number.isInteger(forceKillAfterTimeout) || forceKillAfterTimeout < 0) {\n    throw new TypeError(\"Expected the `forceKillAfterTimeout` option to be a non-negative integer, got `\".concat(forceKillAfterTimeout, \"` (\").concat(typeof forceKillAfterTimeout, \")\"));\n  }\n\n  return forceKillAfterTimeout;\n}; // `childProcess.cancel()`\n\n\nvar spawnedCancel = function spawnedCancel(spawned, context) {\n  var killResult = spawned.kill();\n\n  if (killResult) {\n    context.isCanceled = true;\n  }\n};\n\nvar timeoutKill = function timeoutKill(spawned, signal, reject) {\n  spawned.kill(signal);\n  reject(Object.assign(new Error('Timed out'), {\n    timedOut: true,\n    signal: signal\n  }));\n}; // `timeout` option handling\n\n\nvar setupTimeout = function setupTimeout(spawned, _ref3, spawnedPromise) {\n  var timeout = _ref3.timeout,\n      _ref3$killSignal = _ref3.killSignal,\n      killSignal = _ref3$killSignal === void 0 ? 'SIGTERM' : _ref3$killSignal;\n\n  if (timeout === 0 || timeout === undefined) {\n    return spawnedPromise;\n  }\n\n  if (!Number.isInteger(timeout) || timeout < 0) {\n    throw new TypeError(\"Expected the `timeout` option to be a non-negative integer, got `\".concat(timeout, \"` (\").concat(typeof timeout, \")\"));\n  }\n\n  var timeoutId;\n  var timeoutPromise = new Promise(function (resolve, reject) {\n    timeoutId = setTimeout(function () {\n      timeoutKill(spawned, killSignal, reject);\n    }, timeout);\n  });\n  var safeSpawnedPromise = pFinally(spawnedPromise, function () {\n    clearTimeout(timeoutId);\n  });\n  return Promise.race([timeoutPromise, safeSpawnedPromise]);\n}; // `cleanup` option handling\n\n\nvar setExitHandler = function setExitHandler(spawned, _ref4, timedPromise) {\n  var cleanup = _ref4.cleanup,\n      detached = _ref4.detached;\n\n  if (!cleanup || detached) {\n    return timedPromise;\n  }\n\n  var removeExitHandler = onExit(function () {\n    spawned.kill();\n  }); // TODO: Use native \"finally\" syntax when targeting Node.js 10\n\n  return pFinally(timedPromise, removeExitHandler);\n};\n\nmodule.exports = {\n  spawnedKill: spawnedKill,\n  spawnedCancel: spawnedCancel,\n  setupTimeout: setupTimeout,\n  setExitHandler: setExitHandler\n};","map":null,"metadata":{},"sourceType":"script"}
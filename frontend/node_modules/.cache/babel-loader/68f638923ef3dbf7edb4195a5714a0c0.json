{"ast":null,"code":"'use strict';\n\nvar mergePromiseProperty = function mergePromiseProperty(spawned, promise, property) {\n  // Starting the main `promise` is deferred to avoid consuming streams\n  var value = typeof promise === 'function' ? function () {\n    var _promise;\n\n    return (_promise = promise())[property].apply(_promise, arguments);\n  } : promise[property].bind(promise);\n  Object.defineProperty(spawned, property, {\n    value: value,\n    writable: true,\n    enumerable: false,\n    configurable: true\n  });\n}; // The return value is a mixin of `childProcess` and `Promise`\n\n\nvar mergePromise = function mergePromise(spawned, promise) {\n  mergePromiseProperty(spawned, promise, 'then');\n  mergePromiseProperty(spawned, promise, 'catch'); // TODO: Remove the `if`-guard when targeting Node.js 10\n\n  if (Promise.prototype.finally) {\n    mergePromiseProperty(spawned, promise, 'finally');\n  }\n\n  return spawned;\n}; // Use promises instead of `child_process` events\n\n\nvar getSpawnedPromise = function getSpawnedPromise(spawned) {\n  return new Promise(function (resolve, reject) {\n    spawned.on('exit', function (exitCode, signal) {\n      resolve({\n        exitCode: exitCode,\n        signal: signal\n      });\n    });\n    spawned.on('error', function (error) {\n      reject(error);\n    });\n\n    if (spawned.stdin) {\n      spawned.stdin.on('error', function (error) {\n        reject(error);\n      });\n    }\n  });\n};\n\nmodule.exports = {\n  mergePromise: mergePromise,\n  getSpawnedPromise: getSpawnedPromise\n};","map":null,"metadata":{},"sourceType":"script"}
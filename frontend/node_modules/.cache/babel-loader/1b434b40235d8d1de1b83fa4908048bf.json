{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/tmouchelet-admin/Documents/upload-node-master/frontend/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/tmouchelet-admin/Documents/upload-node-master/frontend/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar isStream = require('is-stream');\n\nvar getStream = require('get-stream');\n\nvar mergeStream = require('merge-stream'); // `input` option\n\n\nvar handleInput = function handleInput(spawned, input) {\n  // Checking for stdin is workaround for https://github.com/nodejs/node/issues/26852\n  // TODO: Remove `|| spawned.stdin === undefined` once we drop support for Node.js <=12.2.0\n  if (input === undefined || spawned.stdin === undefined) {\n    return;\n  }\n\n  if (isStream(input)) {\n    input.pipe(spawned.stdin);\n  } else {\n    spawned.stdin.end(input);\n  }\n}; // `all` interleaves `stdout` and `stderr`\n\n\nvar makeAllStream = function makeAllStream(spawned, _ref) {\n  var all = _ref.all;\n\n  if (!all || !spawned.stdout && !spawned.stderr) {\n    return;\n  }\n\n  var mixed = mergeStream();\n\n  if (spawned.stdout) {\n    mixed.add(spawned.stdout);\n  }\n\n  if (spawned.stderr) {\n    mixed.add(spawned.stderr);\n  }\n\n  return mixed;\n}; // On failure, `result.stdout|stderr|all` should contain the currently buffered stream\n\n\nvar getBufferedData =\n/*#__PURE__*/\nfunction () {\n  var _ref2 = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee(stream, streamPromise) {\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (stream) {\n              _context.next = 2;\n              break;\n            }\n\n            return _context.abrupt(\"return\");\n\n          case 2:\n            stream.destroy();\n            _context.prev = 3;\n            _context.next = 6;\n            return streamPromise;\n\n          case 6:\n            return _context.abrupt(\"return\", _context.sent);\n\n          case 9:\n            _context.prev = 9;\n            _context.t0 = _context[\"catch\"](3);\n            return _context.abrupt(\"return\", _context.t0.bufferedData);\n\n          case 12:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, this, [[3, 9]]);\n  }));\n\n  return function getBufferedData(_x, _x2) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nvar getStreamPromise = function getStreamPromise(stream, _ref3) {\n  var encoding = _ref3.encoding,\n      buffer = _ref3.buffer,\n      maxBuffer = _ref3.maxBuffer;\n\n  if (!stream || !buffer) {\n    return;\n  }\n\n  if (encoding) {\n    return getStream(stream, {\n      encoding: encoding,\n      maxBuffer: maxBuffer\n    });\n  }\n\n  return getStream.buffer(stream, {\n    maxBuffer: maxBuffer\n  });\n}; // Retrieve result of child process: exit code, signal, error, streams (stdout/stderr/all)\n\n\nvar getSpawnedResult =\n/*#__PURE__*/\nfunction () {\n  var _ref6 = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee2(_ref4, _ref5, processDone) {\n    var stdout, stderr, all, encoding, buffer, maxBuffer, stdoutPromise, stderrPromise, allPromise;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            stdout = _ref4.stdout, stderr = _ref4.stderr, all = _ref4.all;\n            encoding = _ref5.encoding, buffer = _ref5.buffer, maxBuffer = _ref5.maxBuffer;\n            stdoutPromise = getStreamPromise(stdout, {\n              encoding: encoding,\n              buffer: buffer,\n              maxBuffer: maxBuffer\n            });\n            stderrPromise = getStreamPromise(stderr, {\n              encoding: encoding,\n              buffer: buffer,\n              maxBuffer: maxBuffer\n            });\n            allPromise = getStreamPromise(all, {\n              encoding: encoding,\n              buffer: buffer,\n              maxBuffer: maxBuffer * 2\n            });\n            _context2.prev = 5;\n            _context2.next = 8;\n            return Promise.all([processDone, stdoutPromise, stderrPromise, allPromise]);\n\n          case 8:\n            return _context2.abrupt(\"return\", _context2.sent);\n\n          case 11:\n            _context2.prev = 11;\n            _context2.t0 = _context2[\"catch\"](5);\n            return _context2.abrupt(\"return\", Promise.all([{\n              error: _context2.t0,\n              signal: _context2.t0.signal,\n              timedOut: _context2.t0.timedOut\n            }, getBufferedData(stdout, stdoutPromise), getBufferedData(stderr, stderrPromise), getBufferedData(all, allPromise)]));\n\n          case 14:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, this, [[5, 11]]);\n  }));\n\n  return function getSpawnedResult(_x3, _x4, _x5) {\n    return _ref6.apply(this, arguments);\n  };\n}();\n\nvar validateInputSync = function validateInputSync(_ref7) {\n  var input = _ref7.input;\n\n  if (isStream(input)) {\n    throw new TypeError('The `input` option cannot be a stream in sync mode');\n  }\n};\n\nmodule.exports = {\n  handleInput: handleInput,\n  makeAllStream: makeAllStream,\n  getSpawnedResult: getSpawnedResult,\n  validateInputSync: validateInputSync\n};","map":null,"metadata":{},"sourceType":"script"}
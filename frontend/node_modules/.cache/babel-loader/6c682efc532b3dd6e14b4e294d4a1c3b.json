{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/tmouchelet-admin/Documents/upload-node-master/frontend/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/tmouchelet-admin/Documents/upload-node-master/frontend/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _slicedToArray = require(\"/Users/tmouchelet-admin/Documents/upload-node-master/frontend/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar execa = require(\"execa\");\n\nvar os = require(\"os\");\n\nvar net = require(\"net\");\n\nvar gwArgs = \"path Win32_NetworkAdapterConfiguration where IPEnabled=true get DefaultIPGateway,GatewayCostMetric,IPConnectionMetric,Index /format:table\".split(\" \");\n\nvar ifArgs = function ifArgs(index) {\n  return \"path Win32_NetworkAdapter where Index=\".concat(index, \" get NetConnectionID,MACAddress /format:table\").split(\" \");\n};\n\nvar spawnOpts = {\n  windowsHide: true\n}; // Parsing tables like this. The final metric is GatewayCostMetric + IPConnectionMetric\n//\n// DefaultIPGateway             GatewayCostMetric  Index  IPConnectionMetric\n// {\"1.2.3.4\", \"2001:db8::1\"}   {0, 256}           12     25\n// {\"2.3.4.5\"}                  {25}               12     55\n\nfunction parseGwTable(gwTable, family) {\n  var bestGw = null,\n      bestMetric = null,\n      bestId = null;\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = (gwTable || \"\").trim().split(/\\r?\\n/).splice(1)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var line = _step.value;\n      line = line.trim();\n\n      var _ref = /({.+?}) +?({.+?}) +?([0-9]+) +?([0-9]+)/g.exec(line) || [],\n          _ref2 = _slicedToArray(_ref, 5),\n          _ = _ref2[0],\n          gwArr = _ref2[1],\n          gwCostsArr = _ref2[2],\n          id = _ref2[3],\n          ipMetric = _ref2[4];\n\n      if (!gwArr) continue;\n      var gateways = (gwArr.match(/\"(.+?)\"/g) || []).map(function (match) {\n        return match.substring(1, match.length - 1);\n      });\n      var gatewayCosts = gwCostsArr.match(/[0-9]+/g) || [];\n\n      var _arr = Object.entries(gateways);\n\n      for (var _i = 0; _i < _arr.length; _i++) {\n        var _arr$_i = _slicedToArray(_arr[_i], 2),\n            index = _arr$_i[0],\n            gateway = _arr$_i[1];\n\n        if (!gateway || \"v\".concat(net.isIP(gateway)) !== family) continue;\n        var metric = parseInt(gatewayCosts[index]) + parseInt(ipMetric);\n\n        if (!bestGw || metric < bestMetric) {\n          bestGw = gateway;\n          bestMetric = metric;\n          bestId = id;\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  if (bestGw) return [bestGw, bestId];\n}\n\nfunction parseIfTable(ifTable) {\n  var line = (ifTable || \"\").trim().split(\"\\n\")[1];\n\n  var _line$trim$split = line.trim().split(/\\s+/),\n      _line$trim$split2 = _slicedToArray(_line$trim$split, 2),\n      mac = _line$trim$split2[0],\n      name = _line$trim$split2[1];\n\n  mac = mac.toLowerCase(); // try to get the interface name by matching the mac to os.networkInterfaces to avoid wmic's encoding issues\n  // https://github.com/silverwind/default-gateway/issues/14\n\n  var _arr2 = Object.entries(os.networkInterfaces());\n\n  for (var _i2 = 0; _i2 < _arr2.length; _i2++) {\n    var _arr2$_i = _slicedToArray(_arr2[_i2], 2),\n        osname = _arr2$_i[0],\n        addrs = _arr2$_i[1];\n\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = addrs[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var addr = _step2.value;\n\n        if (addr && addr.mac && addr.mac.toLowerCase() === mac) {\n          return osname;\n        }\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n  }\n\n  return name;\n}\n\nvar promise =\n/*#__PURE__*/\nfunction () {\n  var _ref3 = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee(family) {\n    var _ref4, stdout, _ref5, _ref6, gateway, id, name, _ref7, _stdout;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return execa(\"wmic\", gwArgs, spawnOpts);\n\n          case 2:\n            _ref4 = _context.sent;\n            stdout = _ref4.stdout;\n            _ref5 = parseGwTable(stdout, family) || [], _ref6 = _slicedToArray(_ref5, 2), gateway = _ref6[0], id = _ref6[1];\n\n            if (gateway) {\n              _context.next = 7;\n              break;\n            }\n\n            throw new Error(\"Unable to determine default gateway\");\n\n          case 7:\n            if (!id) {\n              _context.next = 13;\n              break;\n            }\n\n            _context.next = 10;\n            return execa(\"wmic\", ifArgs(id), spawnOpts);\n\n          case 10:\n            _ref7 = _context.sent;\n            _stdout = _ref7.stdout;\n            name = parseIfTable(_stdout);\n\n          case 13:\n            return _context.abrupt(\"return\", {\n              gateway: gateway,\n              interface: name ? name : null\n            });\n\n          case 14:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, this);\n  }));\n\n  return function promise(_x) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\nvar sync = function sync(family) {\n  var _execa$sync = execa.sync(\"wmic\", gwArgs, spawnOpts),\n      stdout = _execa$sync.stdout;\n\n  var _ref8 = parseGwTable(stdout, family) || [],\n      _ref9 = _slicedToArray(_ref8, 2),\n      gateway = _ref9[0],\n      id = _ref9[1];\n\n  if (!gateway) {\n    throw new Error(\"Unable to determine default gateway\");\n  }\n\n  var name;\n\n  if (id) {\n    var _execa$sync2 = execa.sync(\"wmic\", ifArgs(id), spawnOpts),\n        _stdout2 = _execa$sync2.stdout;\n\n    name = parseIfTable(_stdout2);\n  }\n\n  return {\n    gateway: gateway,\n    interface: name ? name : null\n  };\n};\n\nmodule.exports.v4 = function () {\n  return promise(\"v4\");\n};\n\nmodule.exports.v6 = function () {\n  return promise(\"v6\");\n};\n\nmodule.exports.v4.sync = function () {\n  return sync(\"v4\");\n};\n\nmodule.exports.v6.sync = function () {\n  return sync(\"v6\");\n};","map":null,"metadata":{},"sourceType":"script"}
{"ast":null,"code":"var _toConsumableArray = require(\"/Users/tmouchelet-admin/Documents/upload-node-master/frontend/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar isWindows = process.platform === 'win32' || process.env.OSTYPE === 'cygwin' || process.env.OSTYPE === 'msys';\n\nvar path = require('path');\n\nvar COLON = isWindows ? ';' : ':';\n\nvar isexe = require('isexe');\n\nvar getNotFoundError = function getNotFoundError(cmd) {\n  return Object.assign(new Error(\"not found: \".concat(cmd)), {\n    code: 'ENOENT'\n  });\n};\n\nvar getPathInfo = function getPathInfo(cmd, opt) {\n  var colon = opt.colon || COLON; // If it has a slash, then we don't bother searching the pathenv.\n  // just check the file itself, and that's it.\n\n  var pathEnv = cmd.match(/\\//) || isWindows && cmd.match(/\\\\/) ? [''] : [].concat(_toConsumableArray(isWindows ? [process.cwd()] : []), _toConsumableArray((opt.path || process.env.PATH ||\n  /* istanbul ignore next: very unusual */\n  '').split(colon)));\n  var pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || '.EXE;.CMD;.BAT;.COM' : '';\n  var pathExt = isWindows ? pathExtExe.split(colon) : [''];\n\n  if (isWindows) {\n    if (cmd.indexOf('.') !== -1 && pathExt[0] !== '') pathExt.unshift('');\n  }\n\n  return {\n    pathEnv: pathEnv,\n    pathExt: pathExt,\n    pathExtExe: pathExtExe\n  };\n};\n\nvar which = function which(cmd, opt, cb) {\n  if (typeof opt === 'function') {\n    cb = opt;\n    opt = {};\n  }\n\n  if (!opt) opt = {};\n\n  var _getPathInfo = getPathInfo(cmd, opt),\n      pathEnv = _getPathInfo.pathEnv,\n      pathExt = _getPathInfo.pathExt,\n      pathExtExe = _getPathInfo.pathExtExe;\n\n  var found = [];\n\n  var step = function step(i) {\n    return new Promise(function (resolve, reject) {\n      if (i === pathEnv.length) return opt.all && found.length ? resolve(found) : reject(getNotFoundError(cmd));\n      var ppRaw = pathEnv[i];\n      var pathPart = /^\".*\"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;\n      var pCmd = path.join(pathPart, cmd);\n      var p = !pathPart && /^\\.[\\\\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;\n      resolve(subStep(p, i, 0));\n    });\n  };\n\n  var subStep = function subStep(p, i, ii) {\n    return new Promise(function (resolve, reject) {\n      if (ii === pathExt.length) return resolve(step(i + 1));\n      var ext = pathExt[ii];\n      isexe(p + ext, {\n        pathExt: pathExtExe\n      }, function (er, is) {\n        if (!er && is) {\n          if (opt.all) found.push(p + ext);else return resolve(p + ext);\n        }\n\n        return resolve(subStep(p, i, ii + 1));\n      });\n    });\n  };\n\n  return cb ? step(0).then(function (res) {\n    return cb(null, res);\n  }, cb) : step(0);\n};\n\nvar whichSync = function whichSync(cmd, opt) {\n  opt = opt || {};\n\n  var _getPathInfo2 = getPathInfo(cmd, opt),\n      pathEnv = _getPathInfo2.pathEnv,\n      pathExt = _getPathInfo2.pathExt,\n      pathExtExe = _getPathInfo2.pathExtExe;\n\n  var found = [];\n\n  for (var i = 0; i < pathEnv.length; i++) {\n    var ppRaw = pathEnv[i];\n    var pathPart = /^\".*\"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;\n    var pCmd = path.join(pathPart, cmd);\n    var p = !pathPart && /^\\.[\\\\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;\n\n    for (var j = 0; j < pathExt.length; j++) {\n      var cur = p + pathExt[j];\n\n      try {\n        var is = isexe.sync(cur, {\n          pathExt: pathExtExe\n        });\n\n        if (is) {\n          if (opt.all) found.push(cur);else return cur;\n        }\n      } catch (ex) {}\n    }\n  }\n\n  if (opt.all && found.length) return found;\n  if (opt.nothrow) return null;\n  throw getNotFoundError(cmd);\n};\n\nmodule.exports = which;\nwhich.sync = whichSync;","map":null,"metadata":{},"sourceType":"script"}